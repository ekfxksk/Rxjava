
#Kevin의 알기 쉬운 RxJava  따라하기
- https://www.inflearn.com/course/%EC%9E%90%EB%B0%94-%EB%A6%AC%EC%95%A1%ED%8B%B0%EB%B8%8C%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-1

## 리액티브 프로그래밍이란?
    - 변화의 전파와 데이터 흐름과 과련된 선언적 프로그래밍 패러다임

    > 변화의 전파와 데이터 흐름 : 데이터가 변경될 때 마다 이벤트를 발생시켜서 데이터를 계속적으로 전달한다.
    > 선언적 프로그래밍 : 실행할 동작을 구체적으로 명시하는 명령형 프로그래밍과 달리 선언형 프로그래밍은 단순히 목표를 선언한다.


## 리액티브의 개념이 적용된 예
    1) Push 방식 : 데이터의 변화가 발생했을 때 변경이 발생한 곳에서 데이터를 보내주는 방식
        ex) RTC, 소켓 프로그래밍, DB Trigger, Spring의 ApplicationEvent, 스마트폰의 Push 메시지
        
    2) Pull 방식 : 변경된 데이터가 있는지 요청을 보내 질의하고 변경된 데이터를 가져오는 방식
        ex) 클라이언트 요청 & 서버 응답 방식의 애플리케이션
            Java와 같은 절차형 프로그래밍 언어

    > 리액티브 프로그랭밍도 Push 방식이다.        


## 리액티브 프로그래밍을 위해 알아야 될 것들
    1) Observable : 데이터 소스
    2) 리액티브 연산자(Operators) : 데이터 소스를 처리하는 함수
    3) 스케쥴러(Scheduler) : 스레드 관리자 
    4) Subscriber : Observable이 발행하는 데이터를 구독하는 구독자
    5) 함수형 프로그래밍 : RxJava에서 제공하는 연산자(Operator) 함수를 사용


## RxJava의 기본 프로세스
    1) 발행
    2) 가공
    3) 구독
    4) 처리

## 마블 다이어그램이란?
    - 리액티브 프로그래밍을 통해 발행하는 비동기적인 데이터 흐름을 시간의 흐름에 따라 시각적으로 표시한 다이어 그램

### 마블 다이어그램을 알아야 하는 이유
    - 문장으로 작성된 리액티브 연산자(Operators)의 기능을 이해하기 어려우나
      시각화 되어 있는 리액티브 연산자는 이해햐기 쉽다.
    - 리액티브 프로그램잉의 핵심인 연산자(Operators)를 사용하기 위한 핵심 도구


![image](https://user-images.githubusercontent.com/8993602/155144524-b1279e49-0e91-4ee5-bd6d-ac18a8c5359c.png)


## 리액티브 스트림즈(Reactive Streams)란?
 - 리액티브 프로그래밍 라이브러리의 표준 사양이다.   
   (https://github.com/reactive-streams/reactive-streams-jvm)
 - 리액티브 프로그래밍에 대한 인터페이스만 제공한다.
 - RxJava는 이 Reactive Streams의 인터페이스들을 구현한 구현체 이다.
 - Reactive Streams는 4개의 인터페이스를 제공한다.
    > Publisher : 데이터를 생성하고 통지한다.  
    > Subscriber : 통지된 데이터를 전달받아서 처리한 다.  
    > Subscription : 전달 받을 데이터의 갯수를 요청하고 구독을 해지한다.   
    > Processor : Publisher와 Subscriber의 기능이 모두 있다.

![image](https://user-images.githubusercontent.com/8993602/155240099-b5e7f376-bbc7-430c-8cd1-414606c3a499.png)

## Cold Publisher & Hot Publisher
    1) Cold Publisher
        - 생산자는 소비자가 구독 할때마다 데이터를 처음부터 새로 통지한다.
        - 데이터를 통지하는 새로운 타임 라인이 생성된다.
        - 소비자는 구독 시점과 상관없이 통지된 데이터를 처음부터 전달 받을 수 있다.
    2) Hot Publisher
        - 생산자는 소비자 수와 상관없이 데이터를 한번만 통지한다.
        - 데이터를 통지하는 타임 라인은 하나이다.
        - 소비자는 발행된 데이터를 처음부터 전달 받는게 아니라 구독한 시점에 통지된 데이터들만 전달 받을 수 있다.

## Flowable과 Observable의 비교
    - Flowable, Observable 모두 데이터를 통지하는 생산자

|Flowable|Observable|
|--------|----------|
|Reactive Streams 인테페이스를 구현 함 | Reactive Streams 인테페이스를 구현 하지않고, RxJava2 독자적으로 제공해주는 클래스| 
|Subscriber에서 데이터를 처리한다. | Observer에서 데이터를 처리한다. |
|데이터 개수를 제어하는 배압 기능이 있음 | 데이터 개수를 제어하는 배압 기능이 없음|
|Subscription으로 전달 받는 데이터 개수를 제어할 수 있다. | 배압 기능이 없기 때문에 데이터 개수를 제어할 수 없다. |
|Subscription으로 구독을 해지한다. | Disposable로 구독을 해지한다. |

### 배압(Back Pressure)이란?
    - Flowable에서 데이터를 통지하는 속도가 Subscriber에서 통지된 데이터를 전달받아 처리하는 속도 보다 빠를 때 밸런스를 맞추기 위해 데이터 통지량을 제어하는 기능을 말한다.

![image](https://user-images.githubusercontent.com/8993602/155624163-57ab46ea-82b8-44b5-bc69-432fe5c04e3f.png)

### 배압 전략(BackpressureStrategy)
 - Rxjava에서는 BackpressureStrategy를 통해 Flowable이 통지 대기 중인 데이터를 어떻게 다룰지에 대한 배압 전략을 제공한다.

    1) MISSING 전략
        - 배압을 적용하지 않는다.
        - 나중에 onBackpressureXXX()으로 배압 적용을 할 수 있다.

    2) ERROR 전략
        - 통지된 데이터가 버퍼의 크기를 초과하면 MissingBackpressureExcption에러를 통지한다.
        - 소비자가 생산자의 통지 속도를 따라 잡지 못할 때 발생한다.

    3) BUFFER 전략 : DROP_LATEST   
        - 버퍼가 가득 찬 시점에 버퍼내에서 가장 최근에 버퍼에 들어온 데이터를 Drop 한다.
        - Drop 된 빈 자리에 버퍼 밖에서 대기하던 데이터를 채운다.

    4) BUFFER 전략 : DROP_OLDEST
        - 버퍼가 가득 찬 시점에 버퍼내에서 가장 오래전에(먼저) 버퍼로 들어온 데이터를 Drop한다.
        - Drop 된 빈 자리에는 버퍼 밖에서 대기하던 데이터를 채운다.

    5) DROP 전략
        - 버퍼에 데이터가 모두 채워진 상태가 되면 이후에 생성되는 데이터를 버리고(Drop), 버퍼가 비워지는 시점에 Drop되지 않은 데이터부터 다시 버퍼에 담는다.

    6) LATEST 전략
        - 버퍼에 데이터가 모두 채워진 상태가 되면 버퍼가 비워질 때까지 통지된 데이터는 버퍼 밖에서 대기하며, 버퍼가 비워지는 시점에 가장 나중에(최근에) 통지된 데이터부터 버퍼에 담는다.


## Singel
    - 데이터를 1건만 통지하거나 에러를 통지한다.
    - 데이터를 통지 자체가 완료를 의미하기 때문에 완료 통지는 하지 않는다.
    - 데이터를 1건만 통지하므로 데이터 개수를 요청할 필요가 없다.
    - onNext(), onComplete()가 없으며, 이 둘을 합한 onSuccess()를 제공한다.
    - Single의 대표적인 소비자의 SingleObserver이다.
    - 클라이던트의 요청에 대응하는 서버의 응답이 Single을 사용하기 좋은 대표적인 예다.

## Maybe 
    - 데이터를 1건만 통지하거나 1건도 통지하지 않고 완료 또는 에러를 통지한다.
    - 데이터를 통지 자체가 완료를 의미하기 때문에 완료 통지는 하지 않는다.
    - 데이터를 1건도 통지하지 않고 처리가 종료될 경우에는 완료 통지를 한다.
    - Maybe의 대표적인 소비자는 MaybeOserver이다.

## Completable
    - 데이터 생산자이지만 데이터를 1건도 통지하지 않고 완료 또는 에러를 통지한다.
    - 데이터를 통지의 역활 대신에 Completable 내에서 특정 작업을 수행한 후, 해당 처리가 끝났음을 통지하는 역활을 한다.
    - Completable의 대표적인 소비자는 CompletableObserver이다.


## RxJava의 연산자란(Operator)란?
    - RxJava에서의 연산자는 메서드(함수)이다.
    - 연산자를 이용하여 데이터를 생성하고 통지하는 Flowable이나 Observable 등의 생산자를 생성할 수 있다.
    - Flowable이나 Observable에서 통지한 데이터를 다양한 연사자를 사용하여 가공 처리하여 결과값을 만들어 낸다.
    - 연산자의 특성에 따라 카테고리로 분류된다.

### Flowable/Observable 생성 연산자

#### 1. interval
    - 지정한 시간 간격마다 0부터 시작하는 숫자(Long)를 통지한다.
    - initialDelay 파라미터 이용해서 최초 통지에 대한 대기 시간을 지정할 수 있다.
    - 완료 없이 계속 통지한다.
    - 호출한 스레드와 별도의 스레드에서 실행된다.
    - polling 용도의 작업을 수행할 때 활용할 수 있다.

#### 2. range
    - 지정한 값(n)부터 m개의 숫자(Integer)를 통지한다.
    - for, while 문 등의 반복문을 대체할 수 있다.

#### 3. timer
    - 지정한 시간이 지나면 0(Long)을 통지한다.
    - 0을 통지하고 onComplete() 이벤트가 발생하여 종료한다.
    - 호출한 스레드와는 별도의 스레드에서 실행된다.
    - 특정 시간을 대기한 후에 어떤 처리를 하고자 할 때 활용할 수 있다.

#### 4. defer
    - 구독이 발생할 때마다 즉, subscribe()가 호출될 때마다 새로운 Observable를 생성한다.
    - 선언한 시점의 데이터를 통지하는 것이 아니라 호출 시점의 데이터를 통지한다.
    - 데이터 생성을 미루는 효과가 있기 때문에 최신 데이터를 얻고자할 때 활용할 수 있다.

#### 5. fromIterable
    - Iterable 인터페이스를 구현한 클래스(ArrayList 등)를 파라미터로 받는다.
    - Iterable에 담긴 데이터를 순서대로 통지한다.

#### 6. fromFuture
    - Future 인터페이스는 Java 5에서 비동기 처리를 위해 추가된 동시성 API이다.
    - 시간이 오래 걸리는 작업은 Future를 반환하는 ExcutorService에게 맡기고 비동기로 다른 작업을 수행할 수 있다.
    - Java 8에서는 CompletableFuture 클래스를 통해 구현이 간결해졌다.


### 데이터 필터링 연산자

#### 1. filter
    - 전달 받은 데이터가 조건에 맞는지 확인한 후, 결과가 true인 데이터만 통지한다.
    - 파라미터로 받은 Predicate 함수형 인터페이스에서 조건을 확인한다.

#### 2. distinct
    - 이미 통지된 동일한 데이터가 있으면 이후의 동이한 데이터는 통지 하지 않는다.
    
#### 3. take
    - 파라미터로 지정한 개수나 기간이 될 때까지 데이터를 통지한다.
    - 지정한 범위가 통지 데이터보다 클 경우 데이터를 모두 통지하고 완료한다.

#### 4. takeUntil - 첫번째 유형
    - 파라미터로 지정한 조건이 true가 될 때까지 데이터를 계속 통지한다.

#### 4. takeUntil - 두번째 유형
    - 파라미터로 지정한 Observable이 최초 데이터를 통지할 때까지 데이터를 계속 통지한다.

#### 5. skip - 첫번째 유형
    - 파라미터로 지정한 숫자만큼 데이터를 건너뛴 후 나머지 데이터를 통지한다.

#### 5. skip - 두번째 유형
    - 파라미터로 지정한 시간 동안에는 데이터를 통지를 건너뛴 후 지정한 시간 이 후, 나머지 데이터를 통진한다.

### 데이터 변환 연산자

#### 1. map
    - 원본 Observable에서 통지하는 데이터를 원하는 값으로 변환 후 통지한다.
    - 변환 전, 후 데이터 타입은 달라도 상관없다.
    - null을 반환하면 NullpointException이 발생하므로 null이 아닌 데이터 하나를 반드시 반환해야 한다.

#### 2. falatMap - 첫번쨰 유형
    - 원본 데이터를 원하는 값으로 변환 후 통지한다.
    - 1대 다 변환으로 데이터 한개로 여러 데이터를 통지할 수 있다.
    - 변환 된 여러개의 데이터를 담고 있는 새로운 Observable을 반환한다.
    - 통지 순서를 보장하지 않는다.

#### 2. falatMap - 두번쨰 유형
    - 원본 데이터와 변환된 데이터를 조합해서 새로운 데이터를 통지한다.
    - Observable에 원본 데이터 + 변환된 데이터 = 최종 데이터를 실어서 반환한다.
    - 통지 순서를 보장하지 않는다.

#### 3. conactMap
    - flatMap과 마찬가지로 받은 데이터를 변환하여 새로운 Observable로 반환한다.
    - 반환된 새로운 Observable을 하나씩 순서대로 실행하는 것이 FlatMap과 다르다.
    - 데이터 처리 순서는 보장하지만 처리중인 Observable의 처리가 끝나야 다음 Observable이 실행되므로 처리 성느에는 영향을 줄 수 있다.

#### 4. switchMap
    - concatMap과 마찬가지로 받은 데이터를 변환하여 새로운 Observable로 반환한다.
    - concatMap과 다른점은 switchMap은 순서를 보장하지만 새로운 데이터가 통지되면 현재 처리중이던 작업을 바로 중단한다.

#### 5. groupBy
    - 하나의 Observable을 여러개의 새로운 GroupedByObservable로 만든다.
    - 원본 Obseervable의 데이터를 그룹별로 묵는다기보다는 각각의 데이터들이 그룹에 해당하는 Key를 가지게 된다.
    - GroupedByObservable은 getKey()를 통해 구분된 그룹을 알 수 있게 해준다.

#### 6. toList
    - 통지 되는 데이터를 모두 List에 담아 통지한다.
    - 원본 Observable에서 완료 통지를 받는 즉시 리스트를 통지힌다.
    - 통지되는 데이터는 원본 데이터를 담은 리스트 하나이므로 Single로 반환된다. 

#### 7, toMap
    - 통지 되는 데이터를 모두 Map에 담아 통지한다.
    - 원본 Observable에서 완료 통지를 받는 즉시 Map을 통지한다.
    - 이미 사용중인 key를 또 생성하면 기존에 있던 key와 value를 덮어 쓴다.
    - 통지되는 데이터는 원본 데이터를 담은 Map 하나이므로 Single로 반환된다.

### 데이터 결합 연산자

#### 1. merge
    - 다수의 Observable에서 통지된 데이터를 받아서 다시 하나의 Flowable/Observable로 통지한다.
    - 통지된 시점이 빠른 Observable의 데이터부터 순차적으로 통지되고 통지 시점이 같을 경우에는 merge() 함수의 파라미터로 먼저 지정된 Observable의 데이터부터 통지된다.

#### 2. concat
    - 다수의 Observable에서 통지된 데이터를 받아서 다시 하나의 Observable로 통지한다.
    - 하나의 Observable에서 통지가 끝나면 다음 Observable에서 연이어서 통지가 된다.
    - 각 Observable의 통지 시점과는 사관 없이 concat() 함수가 파라미터로 먼저 입력된 Observable의 데이터부터 모두 통지된 후, 다음 Observable의 데이터가 통지된다.

#### 3. zip
    - 다수의 Observable에서 통지된 데이터를 받아서 다시 하나의 Observable로 통지한다.
    - 각 Observable에서 통지된 데이터가 모두 모이면 각 Observable에서 동일한 index의 데이터로 새로운 데이터를 생성한 후 통지한다.
    - 통지하는 데이터의 개수가 가장 적은 Observable의 통지 시점에 완료 통지 시점을 맞춘다.

#### 4. combineLatest
    - 다수의 Observable에서 통지된 데이터를 받아서 하나의 Observable로 통지한다.
    - 각 Observable에서 데이터를 통지할 때마다 모든 Observable에서 마지막으로 통지한 데이터를 함수형 인터페이스에 전달하고, 새로운 데이터르 생성해 통지한다.

### 예외 처리 연산자
    - try ~ catch 문을 사용하여 예외처리는 불가능하다.

#### 1. onErrorReturn
    - 에러가 발생했을 때 에러를 의미하는 데이터로 대체할 수 있다.
    - onErrorReturn()을 호출하면 onError 이벤트는 발생하지 않는다.

#### 2. onErrorResumeNext
    - 에러가 발생했을 때 에러를 의미하는 Observable로 대체할 수 있다.
    - Observable로 대체할 수 있으므로 데이터 교체와 더불어 에러 처리를 위한 추가 작업을 할 수 있다.

#### 3. retry
    - 데이터 통지 중 에러가 발생했을 때, 데이터 통지를 재시도한다.
    - onError 이벤트가 발생하면 subscribe()를 다시 호출하여 재구독한다.
    - 에러가 발생한 시점에 통지에 실패한 데이터만 다시 통지되는 것이 아니라 처음부터 다시 통지된다.

### 유틸리티 연산자

#### 1. delay 첫번째 유형
    - 생산자가 데이터를 생성 및 통지를 하지만 설정한 시간만틈 소비자쪽으로의 데이터 전달을 지연시킨다.

#### 1. delay 두번째 유형
    - 파라미터로 생성되는 Observable 데이터를 통지할때까지 각각의 원본 데이터의 통지를 지연시킨다.

#### 2. delaySubscription
    - 생산자가 데이터의 생성 및 통지 자체를 설정한 시간만큼 지연시키다.
    - 소비자가 구독을 해도 구독 시점 자체가 지연된다.

#### 3. timeout
    - 각각의 데이터 통지 시, 지정된 시간안에 통지가 되지 않으면 에러를 통지한다.
    - 에러 통지 시 전달되는 에러 객체는 TimeoutException이다.

#### 4. timeInterval
    - 각각의 데이터가 통지되는데 걸린 시간을 통지한다.
    - 통지된 데이터와 데이터가 통지되는데 걸린 시간을 소비자쪽에서 모두 처리할 수 있다.

#### 5. materialize / dematerialize
    - materialize : 통지된 데이터와 통지된 데이터의 통지 타입 자체를 Notification 객체에 담고 이 Notification 객체를 통지한다. 즉, 통지 데이터의 메타 데이터를 포함해서 통지한다고 볼 수 있다.
    - dematerialize : 통지된 Notification 객체를 원래의 통지 데이터로 변환해서 통지한다.

### 조건과 불린 연산자

#### 1. all
    - 통지되는 모든 데이터가 설정한 조건에 맞는지를 판다한다.
    - 결과값을 한번만 통지하면 되기때문에 true/false 값을 Single로 반환한다.
    - 통지된 데이터가 조건에 맞지 않는다면 이후 데이터는 구독 해지되어 통지 되지 않늗나.

#### 2. amb 
    - 여러개의 Observable 중에서 최초 통지 시점이 가장 빠른 Observable의 데이터만 통지되고, 나머지 Observable은 무시된다.
    - 즉, 가장 먼저 통지를 시작한 Observable의 데이터만 통지된다.

#### 3. contains
    - 파라미터의 데이터가 Observable에 포함되어 있는지를 판단한다.
    - 결과값을 한번만 통지하면 되기때문에 true/false 값을 Single로 반환한다.
    - 결과 통지 시점은 Observable에 포함된 데이터를 통지하거나 완료를 통지할 때이다.

#### 4. defaultIfEmpty
    - 통지할 데이터가 없을 경우 파라미터로 입력된 값을 통지한다.
    - 연산자 이름 의미 그대로 Observable에 통지할 데이터가 없이 비어 있는 상태일 때, 디폴드 값을 통지한다.

#### 5. sequenceEqual
    - 두 Observable이 동징한 순서로 동일한 갯수의 같은 데이터를 통지하는지 판단한다.
    - 통지 시점과 무관하게 데이터의 정합성만 판단하므로 통지 시점이 다르더라도 조건이 맞다면 true를 통지나다.

### 데이터 집계 연산자

#### 1. count
    - Observable이 통지한 데이터의 총 개수를 통지한다.
    - 총 개수만 통지하면 됭므로 결과 값은 Single로 반환한다.
    - 데이터의 총 개수를 통지하는 시점은 완료 통지를 받는 시점이다.

#### 2. reduce
    - Observable이 통지한 데이터를 이용해서 어떤 결과를 일정한 방식으로 합성한 후, 최종 결롸를 반환한다.
    - Observable이 통지한 데이터 숫자일 경우 파라미터로 지정한 함수형 인터페이스에 정의된 계산 방식으로 값을 집계할 수 있다.


## Processor와 Subject란?
    - Processor는 Reactive Streams에서 정의한 Publisher 인터페이스와 Subscriber 인터페이스를 둘다 상속한 확장 인터페이스이다.
    - Processor는 Publisher(생산자)의 기능과 Subscriber(소비자)의 기능을 모두 가지고 있다.
    - Processor는 Hot Publisher(뜨거웃 생산자)이다.
    - Subject는 Reactive Streams의 Processor와 동일한 기능을 하나 배압 기능이 없는 추상 클래스이다.

### PublishSubject
    - 구독 전에 통지된 데이터는 받을 수 없고, 구독한 이후에 통지 된 데이터만 받을 수 있다.
    - 데이터 통지가완료 된 이후에 소비자가 구독하면 완료 또는 에러 통지를 받는다.

### AsynSubject
    - 완료 전까지 아무것도 통지하지 않고 있다가 완료했을 때 마지막으로 통지한 데이터와 완료만 통지한다.
    - 모든 소비자는 구독 시점에 상관없이 마지막으로 통지된 데이터와 완료 통지만 받는다.
    - 완료 후에 구독한 소비자라도 마지막으로 통지된 데이터와 완료 통지를 받는다.

#### BehaviorSubject
    - 구독 시점에 이미 통지된 데이터가 있다면 이미 통지된 데이터의 마지막 데이터를 전달 받은 후, 구독 이 후에 토이된 데이터를 전달 받는다.
    - 처리가 완료된 이후에 구독하면 완료나 에러 통지만 전달받는다.

#### ReplaySubject
    - 구독 시점에 이미 통지된 데이터가 있다면 이미 통지된 데이터 중에서 최근 통지된 데이터를 지성한 개수만큼 전달 받은 후, 구독 이후에 통지된 데이터를 전달 받는다.
    - 이미 처리가 완료된 이후에 구독하더라도 지정한 개수 만틈의 최근 통지된 데이터를 전달 받는다.


## 스케줄러(Scheduler)란?
    - RxJava에서의 스케쥴러는 RxJava 비동기 프로그래밍을 위한 쓰레드 (Thread) 관리자이다.
    - 스케줄러를 이용해서 어떤 쓰레드에서 무엇을 처리할 지에 대해서 제어할 수 있다.
    - 스케줄러를 이용해서 데이터를 통지하는 쪽과 데이터를 처리하는 쪽 스레드를 별도로 지정해서 분리할 수 있다.
    - RxJava의 스케줄러를 통해 쓰레드를 위한 코드의 간결성 및 쓰레드 관리의 복잡함을 줄일 수 있다.
    - RxJava에서 스케줄러를 지정하기 위해서 subscribeOn(), observeOn() 유틸리티 연산자를 사용한다.
    - 생산자쪽의 데이터 흐름을 제어하기 위해서느느 subscribeOn() 연산자를 사용한다.
    - 소비자쪽에서 전달받은 데이터 처리를 제어하기 위해서는 observerOn() 연산자를 사용한다.
    - subscribeOn(), observeOn() 연산자는 각각 파라미터로 Scheduler를 지정해야 한다.

### 스케줄러(Scheduler)의 종류
    - RxJava 2.x 스케쥴러 종류.

|스케쥴러|설명|
|--------|----------|
|Schedulers.io() | - I/O 처리 작업을 할 때 사용하는 스케줄러|
|                | - 네트워크 요청처리, 각종 입/출력 적업, 데이터베이스 쿼리 등에 사용|
|                | - 스레드 풀에서 쓰레드를 가져오거나 가져올 쓰레드가 없으면 새로운 쓰레드를 생성한다.|
|Schedulers.computation() | 논리적인 연산 처리 시, 사용하는 스케쥴러
|                         | CPU 코어의 물리적 쓰레드 수를 넘지 않는 범위에서 쓰레드를 생성한다.|
|                         | 대기 시간 없이 빠르게 계산 작업을 수행하기 위해 사요한다.|
|Schedulers.newThread() | - 요청마다 매번 새로운 쓰레드를 생선한다.
|                       | - 매번 생성되면 쓰레드 비용도 많이 들고, 재사용도 되지 않는다.|
|Schedulers.trampoline() | - 현재 실행되고 있는 쓰레드 큐(Queue)를 생성하여 처리할 작업들을 큐에 넣고 순서대로 처리한다. |
|Schedulers.single() | - 단일 쓰레드를 생성하여 처리 작업을 진행한다. |
|                    | - 여러번 구독해도 공통으로 사용한다. |
|Schedulers.from(executor) | - Executor를 사용해서 생성한 쓰레드를 사용한다. |
|                          | - RxJava의 Scheduler와 Executor의 동작 방식이 다르므로 자주 사용되지 않는다. |

## RxJava 디버깅

### RxJava의 디버깅 문제점과 대안
    - RxJava 프로그래밍은 데이터를 생성 및 통지하고 이를 구독하여 처리하는 과정이 하나의 문장으로 되어 있다.
    - RxJava 프로그래밍은 선언적 프로그래밍은 선언적 프로그래밍 방식이기 때문에 데이터의 상태 변화를 확인하기 위한 디버깅이 쉽지 않다.
    - RxJava 프로그래밍은 여러 쓰레드가 동시에 실행되기에 비동기 프로그래밍이기때문에 실행 시 항상 같은 결과가 나온다는 보장을 할 수가 없다.
    - 이러한 문제점을 해결하기 위해 RxJava에서는 doXXX로 시작하는 함수를 통해 생산자나 소비자쪽에서 이벤트 발생 시, 로그를 기록할 수 있는 방법을 제공한다.
    - 함수형 프로그래밍의 특성상 부수 효과는 소비자쪽에서 처리하는 것이 맞미나 doXXX 함수는 예외이다.
    - 따라서 소비자가 전달 받은 데이터를 처리하기 전 원본 데이터의 상태나 변환 및 필터링 등으로 가공되는 시점의 데이터 상태를 doXXX 함수를 통해 쉽게 파악할 수 있다.

### 디버깅을 위한 doXXX 함수

#### doOnSubscribe
    - 구독 시작 시, 지정된 작업을 처리할 수 있다.
    - onSubscribe 이벤트가 발생하기 직전에 실행된다.

#### doOnNext
    - 생산자가 데이터를 통지하는 시점에, 지정된 작업을 처리할 수 있다.
    - OnNext 이벤트가 발생하기 직전에 실행된다.
    - 통지된 데이터가 함수형 인터페이스의 파라미터로 전달되므로 통지 시점마다 데이터의 상태를 확인할 수 있다.

#### doOnComplete
    - 생산자가 완료를 통지하는 시점에, 지정된 작업을 처리할 수 있다.
    - onComplete 이벤트가 발생하기 직전에 실행된다.

#### doOnError
    - 생산자가 에러를 통지하는 시점에, 지정된 작업을 처리할 수 있다.
    - onError 이벤트가 발생하기 직전에 실행된다.
    - 통지된 에러 객체가 함수형 인터페이스의 파라미터로 전달되므로 에러 상태를 확인할 수 있다.

#### doOnEach
    - doOnNext, doOnComplete, doOnError를 한번에 처리할 수 있다.
    - Notification 객체를 함수혐 인터페이스의 파라미터로 전달 받아서 처리한다.

#### doOnCancel / doOnDispose
     - 소비자가 구독을 해지하는 시점에, 지정된 작업을 처리할 수 있다.
     - 완료나 에러로 종료 될 경우에는 실행되지 않는다.

#### doAfterNext
    - 생산자가 통지한 데이터가 소비자에 전달된 직후 호출되는 함수

#### doOnTerminate
    - 완료 또는 에러가 통지 될 때 호출되는 함수 (doOnComplete + doOnError)

#### doAfterTerminate
    - 완료 또는 에러가 통지된 후 호출 되는 함수 (after doOnComplete + doOnError)

#### doFinally
    - 구독이 취소 된 후 완료 또는 에러가 통지된 후 호출되는 함수 (doOndispose/doOnCancel + doOnComplete + doOnError)

#### doOnLifecycle
    - 소비자가 구독할 떄 또는 구독 해지할 떄 호출되는 함수 (doOnSubscribe + doOndispose/doOnCancel)


### 테스트를 위한 blockingXXX 함수
    - 비동기 처리 결과를 테스트하려면 현재 쓰레드에서 호출 대상 쓰레드의 실행 결과를 반환 받을때까지 대기할 수 있어야 한다.
    - RxJava에서는 현재 쓰레드에서 호출 대상 쓰레드의 처리 결과를 받을 수 있는 blockingXXX 함수를 제공한다.
    - Observable에서 통지되고 가공 처리된 데이터를 현재 쓰레드에 반환하므로, 반환된 결과 값과 예상되는 기대값을 비교해서 단위 테스트를 수행할 수 있다.

#### blockingFirst
    - 생산자가 통지한 첫번째 데이터를 반환한다.
    - 통지된 데이터가 없을 경우 NoSuchElementException을 발생 시킨다.

#### blockingLast
    - 생산자가 통지한 마지막 데이터를 반환한다.
    - 통지된 데이터가 없을 경우 NoSuchElementException을 발생 시킨다.
    - 결과를 반환하는 시점이 완료를 통지하는 시점이므로 완료 통지가 없은 데이터 통지일 경우 사용할 수 없다.

#### blockingSingle
    - 생산자가 한 개의 데이터를 통지하고 완료되면 해당 데이터를 반환한다.
    - 2개 이상의 데이터를 통지할 경우에는 IllegalArgumentException을 발생시킨다.

#### blockingGet
    - 생산자가 0개 또는 1개의 데이터를 통지하고 완료되면 해당 데이터를 반환한다.
    - 생산자가 Maybe일 경우 사용할 수 있다.

#### blockingIterable
    - 생산자가 통지한 모든 데이터를 받을 수 있는 Iterable을 얻게 한다.
    - 구독 후, Iterable의 next() 메서드를 호출하는 시점부터 처리한다.

#### blockingForEach
    - 생산자가 통지한 데이터를 순차적으로 모두 통지한다.
    - 통지된 각각의 데이터가 모두 조건에 맞아야 true를 반환한다.

#### blockingSubscribe
    - 통지된 원본 데이터를 호출한 원본 쓰레드에서 부수적인 처리를 할 수 있도록 해준다.
    - 소비자가 전달 받은 데이터로 어떤 부수적인 처리 할 때 이 처리 결과를 테스트 할 수 있다.

### 테스트를 위한 TestSubscriber / TestObserver
    - 테스트 용도로 사용되는 소비자 클래스이다.
    - assertXXXX 함수를 이용해 통지된 데이터를 검증할 수 있다.
    - awaitxxxxx 함수를 이용해서 지정된 시간 동안 대기하거나 완료 또는 에러 이벤트가 발생할 때까지 대기살 수 있다.
    - 완료, 에러, 구독 해지 등의 이벤트 발생 결과 값을 이용해서 데이터를 검증할 수 있다.

#### assertEmpty
    - 테스트 시점까지 통지받은 데이터가 없다면 테스트에 성공한다.
    - Observable.empty()로 생성 시, 완료를 통지를 하기때문에 테스트가 실패한다.
    - 즉, 통지 이벤트 자체가 없는지를 테스트 할 수 있다.

#### assertValue
    - 통지된 데이터가 한개인 경우에 사용한다.
    - 즉, 통지된 데이터가 한개뿐이므로 파라미터로 입력된 값과 같다면 테스트에 성공한다.

#### assertValues
    - 통지된 데이터가 한개 이상인 경우에 사용한다.
    - 즉, 통지된 데이터의 값과 순서가 파라미터로 입력된 값과 순서와 일치하면 테스트에 성공한다.

#### assertNoValues
    - 해당 시점까지 통지된 데이터가 없으면 테스트에 성공한다.
    - 완료 통지와 에러 통지는 테스트 대상에서 제외한다.
    
#### assertResult
    - 해당 시점까지 통지를 완료했고, 통지된 데이터와 파라미터로 입력된 데이터의 값과 순서가 같으면 테스트에 성공한다.
    - assertValues와의 차이점은 해당 시점까지 완료 통지를 받았으냐 받지 않았느냐이다.

#### assertError
    - 해당 시점까지 에러 통지가 있으면 테스트에 성공한다.
    - 단순히 에러 통지가 있었는지의 여부와 구체적으로 발생한 에러가 맞는지를 테스트할 수 있다.

#### assertComplete
    - 해당 시점까지 완료 통지가 있으면 테스트에 성공한다.

#### assertNoTcomplete
    - 해당 시점까지 완료 통지가 없으면 테스트에 성공한다.

#### awaitDone
    - 파라미터로 지덩된 시간 동안 대기시키거나 지정된 시간 전에 완료 통지나 에러 통지가 있다면 통지가 있을때까지만 대기 시킨다.

#### await
    - 생산자쪽에서 완료 통지나 에러 통지가 있을때까지 쓰레드를 대기 시킨다.
    - 파라미터로 지정된 시간동안 대기하며, 대기 시간내에 완료 툥지가 있었는지 여부를 검증한다.

#### awaitCount
    - 파라미터로 지정된 개수만큼 통지될 때 까지 쓰레드를 대기시킨다.